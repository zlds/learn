单体应用:
  - 所有的代码打包在一个包在一个程序中、部署在一个集群上、一个单体应用构成整个系统。

  - 优势:
    1、开发方便
    2、测试、运维方便

  - 缺点:  随着业务的扩展、开发人员的扩增、单体应用越来越臃肿 
    1、开发效率低下、每次测试、上线发布时间久、无法快速迭代。
    2、扩展困难.
    3、稳定性
    - 一个war包、包含了整个应用。系统更新的时候、即使只是更新其中极小的一部分、也要重新打包整个war包、发布整个系统。

    - 代码分支管理困难
  
分布式架构:
  单机模式: 指的是、所有业务和数据均部署到同一台机器上。好处是功能、代码和数据集中、便于维护、管理和执行。
  单机模式的主要问题: 性能受限、存在单点失效的问题。
  
  - 简单来说就是系统由多个独立的应用组成、它们互相协作、成为一个整体。
  - 多个应用、每个应用分别负责不同的业务线。当一个应用需要另一个应用的功能时、会通过API接口进行调用。

微服务:
  - 将大一统的应用、拆分成多个模块、这些模块独立开发、独立部署。
  - 独立开发
  - 独立部署
  - 低耦合
  - 高内聚


微服务带来的挑战:
  - 依赖关系复杂
  - 持续交付
  - 容器化环境
  - 服务注册、发现和可靠性
  - Devops




微服务面临的难题是：拆分原则是什么？如何拆分？以及面临那些潜在风险？
  拆分原则：小而专。即微服务内"高内聚"，微服务间"低耦合"。

    高内聚：就是指单一职责，将代码修改的范围缩小到这个微服务内。
    微服务间低耦合：在微服务实现自身业务的过程中，如果需要执行的某些过程不是自己的职责，应当将这些过程交给其他微服务去实现，你只需要对它的接口进行调用。





在设计微服务的时候，我看到以下三个问题
  第一个问题是：当多个团队都在向你提出API接口时，你怎么提供接口？如a、b、c等都来向我获取数据，那么我该如何做呢？
  作者的回答是：对这些接口进行划分，通过复用尽可能少的接口满足他们的需求。

  第二个问题是：当调用方需要接口变更时怎么办？
  作者的回答是：变更现有接口应当尽可能向前兼容，即接口的名称与参数都不变，只在内部增加新的功能。如果真的需要参数变更怎么办，那么宁愿增加一个新的接口，也不能变更原有的接口。

  第三个问题：调用双方传递的值对象需要完全一致吗？
  作者的回答是：不用。被调用方增加了参数，调用方并不需要变更，调用都是通过rest接口以json形式传递数据，是一种松耦合的调用。所以调用双方的参数可以不一致，这样就降低了微服务变更带来的更新范围。





平台:
  - 因为在当今互联网时代、用户才是商业战场的中心、为了快速响应用户的需求、借助平台化的力量可以事半功倍。

中台:
  核心思想将以往业务系统中可复用的前台与后台代码提前出来，形成公用组件。

  - 中台的思想是将不同的业务中相同或相似的基础服务沉淀到统一的中台应用中。如将所有的业务中台会员服务沉淀为会员中台。
  - 避免烟囱式产品、同时大幅度降低新产品的构建成本和运营成本。

  - 好处:
    1、减少重复开发。如每个系统不需要在单独开发会员、订单等。
    2、增加服务的复用。能够沉淀到中台的必然是多个应用能够适用的通用逻辑。
    3、快速构建前台应用。如果要增加一个新应用系统、只需要快速构建一层前台应用即可上线。
    4、数据打通。不同的业务的基础中台数据有相同的数据模型、可以统一调用。




雪崩:
  - 局部故障最终导致全局故障
  - 服务调用方等待服务提供方的响应时间过长、它的资源被耗尽、才引发的级联反应、发生雪崩。
  - 最怕响应缓慢。响应一慢、就会出现雪崩拖垮整个系统


超时:
  - 避免服务迟迟没有返回调用结果、把消费者给拖死。
  - 一切服务端的调用、都要设置超时时间。
  优点:
    - 避免雪崩、和资源浪费
    - 超时时间怎么取: 可以根据消费者的水平来决定、以99.9%或者99.99%的调用都在多少毫秒内返回为准。
  注意事项:
    - 超时传递:
      如A服务设置100ms--->B服务300ms    造成没必要的资源浪费
 
隔离:
  - 线程池:
      通过对相同的资源、设置线程池、然后将资源放到线程池里面、通过设置线程池中的大小、和超时时间、来控制资源的访问、来达到隔离的效果

    缺点:
      资源消耗比较大、因为有大量的上下文切换、包括一些创建线程池开销。

  - 信号量、通过观察线程的信号量、针对同一种资源计算他的线程数、一旦请求超过阀值之后、然后快速阻断请求、来达到隔离效果。


降级:
  - 保证核心功能可用、是一种有损的系统容错方式。
  - 如电商系统在商品详情页除了展示数据之外、还要展示评论数据、出现问题时、可用关闭评论。
  - 被动措施、因为它一般是系统以及出现故障后所采取的一种止损措施。


限流:
  - 当流量超过了系统的最大容量后、就会导致系统响应变慢、服务超时。
  - 根据系统的最大容量、给系统设置一个阀值、超过阀值的请求会被自动抛弃。

  注意事项:
  - 为系统中每个服务的请求量也设置一个阀值、超过这个阀值也要被自动抛弃。

  - 衡量指标:
    - QPS: 每秒请求数。不过QPS因为不同服务的影响快慢不同、所以系统能够承载的QPS相差很大。因此一般选择工作线程数。
    - 线程数

流控:
  超过、排队、来达到削峰填谷的效果。

最后、只有经过演练的开关才是有用的开关。 对于上线新功能必然要加开关控制业务逻辑是运行新的功能还是旧的功能、这样新功能上线之后、出现问题、可以用开关发送来实现快速回滚。



熔断:  错误或异常超过一定比率、停止对这个服务的调用、或者让服务快速返回、来保护调用方。

    - 就是在检测到某一个服务的响应时间出现异常时、切断调用它的服务与之间的联系、让服务的调用快速返回失败、从而释放这次请求持有的资源。

    组件:  HYSTRIX   Sentinel
    - 把客户端的每一次服务调用用断路器封装起来、通过断路由来监控每一次服务调用
     如果在某个时间段、服务调用失败次数达到预定阈值时、断路由就会被触发、后续的服务调用就直接返回、也就不会再向服务提供者发起请求了
     状态:
          Closed状态: 
                    正常情况下、处于关闭状态.
          Open状态:
                    当服务调用失败次数达到一定阈值时、就会处于开启状态、后续的服务调用就直接返回、不会向服务提供者发起请求.
          Half Open:
                    当处于开启后、每隔一段时间、会进入半打开状态、这时会向服务提供者发起探测调用、以确定服务提供者是否恢复正常。如果调用成功、就关闭。如果没成功就保持开启状态。

配置中心:
        配置中心的思路就是把服务的各种配置、如代码里配置的各种参数、服务降级的开关甚至依赖的资源等都在一个地方统一进行管理。


微服务治理平台:
             注册中心
             配置中心
             监控系统
             服务追踪系统
             日志系统
             容器管理平台        



容量评估:
        压测指标:
          系统类指标: 如CPU使用率、内存占用量、磁盘I/O使用率以及网卡带宽等
          服务类指标: 接口响应的平均耗时、P999耗时、错误率

ENTRYPOINT 和 CMD

entrypoint和cmd都是让用户指定一个可执行程序、这个可执行程序在container启动后自动启动


注册中心:
  如何让让RPC客户端知道服务端部署的地址。


Eureka机制:
  无中心化架构:
  eureka集群解决单点问题、不同与zk选举leader、而是用peer to peer对等通信、节点彼此相互注册提供高可用。

  默认90秒时间内、没有接到某个服务实例的心跳、注销该实例。

  节点短时间内丢失过多的心跳时(如发生了网络分区故障)、节点进入自我保护模式、不在注销服务实例、设计哲学、
  宁可保留错误的服务注册信息、也不盲目注销任何困难健康的服务实例


zk 基于CP、不保证高可用、选举主节点、集群半数以上机器不可用、无法获得数据
Eureka基于AP、保证高可用、即使所有机器都挂了、也能拿到本地缓存的数据


分布式事务:
  - 保证不同的数据库中数据一致性的解决方案

  强一致性:   
    - 2PC  流程同步 阻塞  
    - 3PC  引入超时
  最终一致性:
    - TCC 模式  预判 提交 回滚
    - 可靠消息投递模式
    - 补偿模式  