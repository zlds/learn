正则分类:
	- 基础
		- . 任意字符(除换行除外)
		- \d 任意数字 \D任意非数字
		- \w 任意字母、数字、下划线  \W 字母、数字 下划线以外的任意字符
		- \s 任意空白符  \S 任意非空符

	- 空白符
		- \r  回车符
		- \n  换行符
		- \f  换页符
		- \t  制表符
		- \v 垂直制表符
	- 范围
		- | 如ab|bc 代表ab 或 bc
		- [..] 多选一 括号中任意单个元素
		- [a-z] 匹配a到z之间任意单个元素(按ASCII表、包含a,z)
		- [^...] 取反
	- 边界
		- ^ 开头
		- $ 结尾
		- \b 单词边界
		- \A 整个字符串开始 不支持多行模式
		- \Z 整个字符串结束 不支持多行面试
	- 量词
		- * 0到多次
		- + 1到多次
		- ? 0到1次
		- {m} 出现m次
		- {m,n} 出现m到n次
	- 子组
		- () 将regex 保存成一个子组
		- (?P<name>正则) 命名子组、将regex保存成名称为name的子组
		- (?:正则) 仅分组、不保存这个子组
		- \ 分组编号、重复某个子组	




正则表达式:
	- 普通字符: a-zA-Z
	- 特殊字符:	元字符。 如要匹配特殊字符、必须转移字符、即在字符前面加反斜杠\。
				在中括号表达式出现时将失去本来的意义、并恢复为普通字符。
	.  除换行符\n 之外的任何单个字符
	\d 等介[0-9]
	\D 等介[^0-9]
	\w 与以下任意字符匹配: A-Z a-z 0-9和下划线、[A-Za-z0-9]
	\W 与\w相反	
	\s 匹配一个空格(包括Tab等空白符)		

	限定符:
		{n} 匹配n次
		{n,} 至少匹配n次
		{n,m} 至少匹配n次、至多m次
	定位点:
			^ 开头
			$ 匹配结尾的位置
			\b 与一个字符边界匹配

egrep -o "([0-9]{1,3}\.){3}[1-9]{1,3}" access.log 查找ip

普通HASH:
	- 按服务器编号进行取模
	- 缺点:
		当服务器节点变化时(新增或者删除)、大部分缓存失效、可能会引起系统压力过大而崩溃。


一致性HASH:
	- 一致性hash是对2^32取模。然后根据ip进行哈希、hash(ip) % 2^32 
	- hash(xx.jpg) % 2^32 按顺时针方向找、找到第一个节点。


	需要进行两次映射:
		- 给每个节点计算hash、然后记录他们的hash值。
		- 给每个key计算hash、然后沿着顺时针的方向找到环上的第一个节点。就是该key存储对应的集群。

	节点删除时:
		- 如节点1删除时、其余的节点不会发生改变、只是原来在节点1上的key、会转移到顺时针方向的下一个节点上去。
		- 增加一个节点也是同样的、最终只有少部分key发生了失效。

	问题:
		1、数据倾斜: 理想情况下、节点是均匀的、但是会发生严重的数据的倾斜。
		2、缓存雪崩: 如果每个节点在环上只有一个节点、当失效时、原本负责的任务将全部交给下一个节点处理、这就意味着下一个节点压力瞬间增大。		

	- 平衡性:
		- 指哈希的结果能尽可能分不到所有的节点上、这样使得所有的节点能够充分利用
	- 单调性:
		- 指如果已经有一些内容通过哈希分布到相应的节点上去、又有新的节点加入、哈希的结果应该能够保证原有的、已分配的内容可以被映射到原有的或者新的节点上、而不会被映射到旧节点的之外的其他节点上。


	- 虚拟节点: 一致性哈希算法在服务节点太少时、容易造成节点分布不均匀而造成数据倾斜问题。
				  具体做法: 是将节点ip或者主机名、进行多次哈希。只是多了一步虚拟节点映射到物理节点上。	



在计算机内部、所有的信息最终都是二进制形式、每一个二进制位(bit)有0和1两种状态、八个二进制表示一个字节、
一个字节可表示256种状态、每一个状态对应一个符号。				  	

ASCII: 
	- 规定了英文字符与二进制位的对应关系. asicc一共规定了128个字符编码。

	asicc只规定了128个编码、对于其他国家显然不够用、不同国家有自己新增了编码、而每个国家的编码对应关系又不一样、所以unicode就是包含所有的符号。

	存在问题:
		- 同一个二进制数可以被解释成不同的符号、因此要想打开一个文本文件就必须知道它的编码方式。


Unicode:  字符集
	- 包含所有符号、每一个符号都给予一个唯一的编码。unicode是一个很大的集合
	
	存在问题
	- 并没有规定这个二进制代码应该如何存储

UTF-8:
	- 是Unicode的实现方式之一
	- 是一种变长的编码方式。可以使用1-4个字节表示一个符号、根据不同的符号而变化字节长度

	如果第一个字节的第一位是0、则🇨这个字节单独就是一个字符
	如果第一位是1、则连续有多少个1、就表示当前字符占用多少个字节