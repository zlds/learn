一次编译到处运行: 
  javac 将源码编译成class文件(字节码)、jvm不关心class来源是什么、只要符合规范/结构、就可以在jvm上运行

java虚拟机规定、一个类或者接口在初次使用前、必须要进行初始化
class文件装载流程：
  加载>连接(验证准备解析)>初始化

本地机器指令：一种能够被CPU直接识别并执行的指令、它以二进制编码作为表示形式。通常有两部分组成、操作码和操作数、操作码决定了指令需要执行什么样的功能、而操作数指定了需要参与与运算的操作数。

JIT编译器:
   是一个把java的字节码翻译成对应的机器指令、逐条读入、逐条解释翻译。
   在任何平台上、java都会将编译好的字节码解释成能被特定的处理器所理解的指令。

JIT三种执行方式：解释执行、编译执行、混合执行。default混合模式
   解释执行：所有代码均为解释执行、不做任何JIT编译 Xint
   编译执行：和解释执行相反、对所有的函数、无论是否是热点代码、都会被编译执行 Xcomp
   混合执行：部分函数会被解释执行、部分可能被编译执行。

JIT 热点代码依据:
   虚拟机决定函数是否需要编译执行的依据是判断该函数是否为热点代码。反复使用
   编译器线程的数量可以通过：XX:CICompilerCount=N flag 进行调节设置   
   热点代码: 被多次调用的方法。被多次执行的循环体。

编译触发条件: 
   热点探测: 判断一段代码是不是热点代码的依据
    1、基于计数器的热点探测: 虚拟机会为每个方法(或代码块)建立计数器、统计执行次数、如果超过阈值就是热点代码。
      缺点是维护计数器开销
    2、基于采样的热点探测:虚拟机会周期性检查各个线程的栈顶、如果某个方法经常出现在栈顶、那么就是热点代码。缺点是不精确
    3、基于踪迹的热点探测: Dalvik中的JIT编译器使用这种方式

   XX:CompileThreshold=xxx 设置计数器/默认是10000次、也就是说一个方法或者一个循环被执行10000次、那么就会编译成本地机器指令

  
GC:
    作用就是JVM中自动内存管理机制的具体实现。
    主要内容分为两大块:
        分别是动态分配和垃圾回收

垃圾标记算法:
   引用计数器
   根搜索算法
引用计数算法:
   为对象添加一个引用计数、用于记录对象被引用的情况、如果计数为0、即表示对象可回收。
  通过引用计数器来判断一个对象是否可以被回收！

  特点简单、效率高、但是无法解决循环引用的问题。

  引用计数器的缺陷：
                 性能：加减、引用加一、去引用减一
                 循环引用的对象无法进行回收

根搜索算法：
  设立若干种根对象、当任何一个根对象到某一个对象均不可达时、则认为这个对象是可以被回收的。
            从根GC Roots的对象作为起点、开始向下搜索、搜索所走的路径称为"引用链"。

根(GC Roots) 常量，类静态属性，栈帧中的本地变量表。
   栈中引用的对象
   方法区中的静态成员
   方法区中的常量引用的对象(全局变量)
   本地方法栈中的JNI(一般的Native方法)引用的对象



垃圾收集器算法:
MarkSweep 标记清除
   算法:分为2过阶段标记阶段和清除阶段。
       标记阶段的任务是标记出所有需要被回收的对象
       清除阶段结就是回收被标记的对象所占用的空间。

   缺陷就是容易产生碎片、碎片太多可能会导致后续的过程中为大对象分配空间无法找到连续足够的空间而提前触发新的一次垃圾收集动作

Copying 复制
   为了解决MakeSweep算法的缺陷、它将可用内存按容量划分为大小相等的两块、每次只使用其中的一块、当这一块内存用完了、就将还存活的对象复制到另外一块上面、然后在把已使用的内存空间一次清理掉、这样就不容易出现碎片！
   缺陷
    1、内存代价高
    2、copying跟存活对象的数目有很大的关系、如果存活对象很多、那么copying算法的效率将会大大降低。

MarkCompact 标记整理 
   为了解决Copying算法的缺陷、充分利用内存空间提出了Markcompact算法、该算法标记阶段和MarkSweep一样、但是在完成标记之后、不是直接清理可回收对象、而是将存活对象都向一端移动、然后清理掉端边界以外的内存。

Generational Collection 分代收集
   分代收集算法的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况将堆划分为老年代(Tenured Generation)和新生代(Young Generation)
、老年代的特点是每次垃圾收集时只有少量对象需要被回收、而新生代的特点是每次垃圾回收都有大量的对象需要被回收。


Young内存
   98%的对象是朝生夕死、所以不需要按照1:1来划分内存空间、而是将内存分为一块较大的Eden空间和两个较小的Survivor空间、每次使用Eden和其中一块Survivor。当回收时、将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上。
   Eden和Survivor 默认比例是8:1



线程私有:
 栈：每个线程执行每个方法的时候都会在栈中申请一个栈帧、每个栈帧包括局部变量区和操作数栈、用于存放此方法调用过程中的临时变量、参数和中间结果。
 本地方法栈：用于支持native方法的执行、存储了每个native方法调用的状态。
 方法区：存放了要加载的信息、静态变量、final类型的常量、属性和方法信息。


线程共享：
   堆:
      唯一使命存放实例
   方法区(存储每一个java类的结构信息：运行时的常量、字段和方法数据、构造函数和普通方法的字节码内容
  以及类、实例、接口初始化时需要用到的特殊方法等数据。)、运行时常量池(属于方法区的一部分、一个有效的字节码文件包含文件中除了包含类的版本信息、字段、方法)



类的回收：只有无用的类才可以回收，类需要同时满足下面3个条件才能算是"无用的类"

1、该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
2、加载该类的ClassLoader已经被回收。
3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。


如何确定某个对象是垃圾：
 在java中是通过引用来和对象进行关联的、也就是说如果要操作对象、必须通过引用来进行。
 如果一个对象没有任何引用与之关联、则说明该对象基本不太可能在其他地方被使用到、那么这个对象就成为可被回收的对象了。

引用的类型：
          强引用：默认情况下、对象采用的均为强引用(对象的实例没有其他对象引用、GC时才会被回收)
          软引用：是java中提供的一种比较适合缓存场景的应用(只有在内存不够用的情况下才会被GC)
          弱引用：在GC时一定会被GC回收
          虚引用：虚引用只是用来得知对象是否被GC


卡表：卡表作为一个比特位的集合、每一个比特位可以用来表示老年代的某一区域中的所有对象是否持有新生代对象的引用
     卡表为1时 需要扫描给定区域的老年代对象、为0时不需要扫描年老代
     1位表示年老代4K空间


http://caoyaojun1988163com.iteye.com/blog/1969853


晋升老年代：
   年龄和空间比率：对象的实际晋升年龄是根据survivor区的使用情况动态计算得来的、而maxtenuringthreshold只是表示这个年龄的最大值
   大的对象：当eden区和survivor区无法容纳这个对象、很有可能直接晋升到老年代

XX:MaxTenuringThreshold
  设置对象进入老年代的年龄最大值默认15。每一次MinorGC后、对象年龄就加1。然后大于这个年龄的对象、一定会进入老年代 
XX:PretenureSizeThreshold 
  设置大对象直接进入老年代的阀值。当对象大小超过这个值时、将直接在老年代分配。



X   选项是非标准的(不能保证在所有VM实现上都受支持) 如有更改、恕不另行通知
XX  指定的选项是不能稳定 如有更改、恕不另行通知

java XX:+PrintFlagsInitial 查看可配置参数

并行
  是指应用程序线程暂停、同时由多个线程一起执行GC。
并发
  是指收集器和应用线程交替执行。



如何将分区调整到合适的大小:
   分析活跃数据的大小。是个切入点
   活跃数据的大小是指: 应用程序稳定运行时、长期存活对象在堆中占用的空间大小。也就是Full GC后堆中老年代占用空间的大小。可以通过GC日志中的Full GC之后的老年代数据大小得出。比较准确的方法是在程序稳定后、多次获取GC数据、通过取平均值的方式计算活跃数据的大小。

堆大小设置:
  Xms3072m 初始堆大小
  Xmx3072m 最大堆大小
  Xmn Young大小
  Xss  栈大小
  XX:NewRatio 新生代与老年代的比率。XX:NewRation=4时、表示新生代与老年代所占的比值为1:4。如果已经设置了Xmn、则无需设置该选项





垃圾回收器： 串行/并行
 串行：
       XX:+UseSerialGC: 
             单线程、独占式。 
             新生代 复制

       XX:+UseSerialOld 
             单线程、独占式。
             老年代
             标记压缩
并行：
       XX:+UseParNewGC：
             多线程、独占式。
             新生代使用ParNew、老年代使用串行。
             新生代 复制

       XX:+UseParallelGC: 
             多线程、独占式。关注系统的吞吐量。
             年轻代使用ParallelGC、老年代使用串行。
             新生代 复制

       XX:+UseParallelOldGC: 
             多线程、独占式。
             新生代使用ParallelGC、老年代使用ParallelOldGC。
             标记压缩
   

ParallelGC和ParNew的不同之处、ParallelGC可以控制程序吞吐量大小、也就是吞吐量优先、主要有2个参数：
       XX:MaxGCPauseMillis：
            设置最大垃圾收集停顿时间。

       XX:GCTimeRatio：
            设置吞吐量大小。设置执行内存回收的时间所占JVM运行总时间的比例、默认值为99、就是说只有1%的时间用于执行内存回收

       XX:UseAdaptiveSizePolicy
            自适应GC策略

      XX:ParallelGCThreads 
            可以指定线程数量最好与cpu数量相等         

CMS:   设计目标是尽量减少停顿时间。
       主要关注系统停顿时间、低延迟 标记清除  获取最小的停顿时间
       将Java堆分为年轻代和老年代。主要原因是因为90%的对象在第一次GC时就被回收掉、少数对象往往会存活较长的时间。


       XX:+UseConcMarkSweepGC:
            相当于"ParNew" + "CMS" + "Serial Old"、即在young generation中采用ParNew、多线程、在tenured gentration使用CMS、以求得最低的暂停时间。

             新生代 复制
             老年代 标记清除

       XX:ConcGCThread
            设置并发线程数量

       XX:ParallelCMSThreads
            设置并发线程数量

       XX:CMSInitiatingOccupancyFraction=xxx
            指定回收阀值、即当老年代的空间使用率超过xx%时、会执行一次CMS回收
       
       XX:CMSScavengeBeforeRemark 
            remark 之前先进行一次yonggc 并不一定会执行、如果remark不是性能瓶颈不开启也好、毕竟要执行一次ygc

        XX:+CMSParallelRemarkEnabled 
            开启并行remark(仅与parnewGC结合使用) 
        XX:ExplicitGCInvokesConcurrent
          打开此参数后，在做System.gc()时会做background模式CMS GC、即并行FULL GC，可提高FULL GC效率
         注，该参数在允许systemGC且使用CMS GC时有效


GC优化步骤: 
  1、确定目标
  2、优化参数
  3、验收结果。


注(当出现Concurrent Mode failure或promotion failed时则采用串行GC)
promotion failed:
    是说在ygc时、发现odl内存不足(碎片问题、空间不连续)、转而执行full gc
    所有要升级的年轻对象都必须在旧一代内存中的连续地址空间中进行分配
    解决方法: 减少eden大小并增加堆大小、或者设置old的回收百分百

concurrent mode failure:
    1.一个是在年老代被用完之前不能完成对无引用对象的回收
    2.当新空间分配请求在年老代的剩余空间中得不到满足
    ygc时old空间不足、转而执行full GC
    在执行CMS时的过程中、同时有对象要放入到old空间、而此时old空间不足造成的

Full GC:
  除了CMS和G1、其余垃圾回收器都是回收整个堆
       XX:+UseCMSCompactAtFullCollection  默认为True
            CMS在垃圾收集完成后、进行一次内存碎片整理、内存碎片的整理不是并发进行的。

       XX:CMSFullGCsBeforeCompation  
            默认是0、也就是在默认配置下每次CMS GC顶不住了而要转入full GC的时候都会做压缩。依赖前者开启

Partial GC: 并不收集整个GC堆的模式
   Young GC: 只收集young gen的GC
   Old GC: 只收集old gen的GC。只有CMS的concurrent collection是这个模式
   Mixed GC: 收集整个yong gen以及部分old gen的GC。只有G1有这个模式

Full GC: 收集整个堆、包括young gen、old gen、perm gen(如果存在的话)等所有部分的模式


G1:
     应用在多处理器和大内存环境中、在实现高吞吐量的同时、尽可能的满足垃圾收集暂停时间的要求。
     兼顾吞吐量和停顿时间。
     将内存划分大小相等的区域、默认把堆内存按照2048份均分、最后得到一个合理的大小
     Regino 之间是复制算法、但整体上可用看作是标记整理算法、可用有效的避免内存碎片。

  G1 核心概念:
     Region  G1 空间不连续 
       每一代都使用了N个不连续的大小相同的Region
       传统的GC收集器将连续的内存空间划分为新生代、老年代和永久代、这种划分各代的存储地址是连续的
       XX:G1HeapRegionSize设定、取值范围从1M到32M、且是的指数。
     Humongous对象: 超过region 50%的对象
       G1将超过region 50%大小的对象、归类为Humongous对象、并放置在相应的region中。
       逻辑上、Humongous region 算是老年代的一部分、因为大对象复制是很昂贵的操作、不适合新生代GC的复制算法

  Rset: 记录和维护region之间的对象引用关系。
     每个内存区域、都会有一个rset、
     记录其他region引用当前regioin对象的引用
  Cset:  clientset
     本次GC需要清理的Region集合  

    XX:+UseG1GC
        启用G1
    XX:MaxGCPauseMillis =50(ms)
        设置gc停顿时间    
    XX:G1HeapRegionSize
        指定region大小、取值1M到32M、且是2的指数
    XX:InitiatingHeapOccupancyPercent=XX
        当老年代大小占整个堆大小百分百达到该阈值时、会触发一次mixed gc  

  G1 垃圾回收
     Young GC 回收年轻代 选定所有年轻代里的Region。
     Mixed GC 老年代   不是Full GC 它只能回收部分老年代的Region、如果mixed GC 实在无法跟上程序分配内存的速度、导致老年代填满无法继续进行Mixed GC、就会使用serial old GC 来收集整个GC heap
     在新生代、G1采用的仍然是并行的复制算法、所以同样会发生StopTheWorld的暂停
     在老年代、大部分情况下都是并发标记、而整理则是和新生代GC时捎带进行、并且不是整体性的整理、而是增量进行的

  G1:
     是一个有整理内存过程的垃圾收集器、不会产生很多内存碎片
     G1的STW更可控、G1在停顿时间上添加了预测机制、用户可以指定期望停顿时间。
日志:
       XX:+PrintGCDateStamps  打印垃圾收集器开始执行的时间戳 
       XX:+PrintGCDetails     打印详细信息
       XX:+PrintHeapAtGC      打印GC前后的堆栈信息
       XX:PrintGCApplicationStoppedTime 打印程序暂停时间
       Xloggc:/xxx/xx.gc.log  指定GC日志的输出路径 

XX:+CMSClassUnloadingEnabled
这个参数表示在使用CMS垃圾回收机制的时候是否启用类卸载功能。默认这个是设置为不启用的。
如果你启用了CMSClassUnloadingEnabled ，垃圾回收会清理持久代，移除不再使用的classes。这个参数只有在 UseConcMarkSweepGC  也启用的情况下才有用。 如果你是使用Java6或者后面更高的版本。那么解决持久代内存大小问题的参数看起来会是下面这样子：
XX:MaxPermSize=128m XX:+UseConcMarkSweepGC XX:+CMSClassUnloadingEnabled
      

主要步骤：
    初始标记   STW：标记根对象 GCRoot
	并发标记   标记所有对象 从GCRoot开始向下搜索
	预清理     清理前准备以及控制停顿时间
	重新标记   STW：修正并发标记数据。 并发标记时是和用户线程同时工作的
	并发清除   清理垃圾
	并发重置   重新初始化CMS数据结构和数据



G1 GC的模式:
    young gc:
        发生在年轻代的GC算法。执行完一次young gc、活跃对象会被拷贝到survivor region或者晋升到old region中、空闲的region会被放入空闲列表中、等待下次被使用。
    mixed gc:
        当越来越多的对象晋升到老年代old region时、为了避免堆内存耗尽、虚拟机会触发一个混合的垃圾收集器、即mixed gc、
        在回收young region时、还会回收一部分的old region
    Full gc:
        如果对象内存分配速度过快、mixed gc来不及回收、导致老年代被填满、就会触发一次full gc、full gc算法就是单线程执行的seri old gc。
        在混合gc时发生空间不足或者新生代GC时、survivor区和老年代无法容纳幸存对象、都会导致一次full gc

    GC 时间:
       如果用户空间时间比较长、则表示没有足够的CPU用于用户线程。如果系统时间很长、则表示系统正在将内存交换到磁盘、这意味着堆大小的物理内存不足。    



G1比CMS具有以下优势:
   没内存碎片
   空间不连续。通常将堆分成许多非常小的区域。默认是2MB

   g1是一个有整理内存过程的垃圾收集器、没有内存碎片
   g1的stw更可控、g1在停顿时间上添加了预测机制、用户可以指定期望停顿时间
   cms 是将内存空间划分为新生代、老年代、永久代(jdk8是metaspace)、这种划分的特点是各代的空间地址是连续的
   G1的空间地址是不连续的、每一代都使用了n个不连续的大小相同的region

G1 场景:
   服务端多核CPU、JVM内存占用较大的应用
   应用在运行过程中产生大量内存碎片、需要经常压缩空间



G1
   也是有年代概念、只是将内存划分一个个region
   region的大小是一致的、数值是在1M到32M字节之间的一个幂等数、jvm会尽量划分2048个左右、同等大小的region
   空间是不连续、将堆空间划分成相互独立的区块、每个区块既有可能属于O、也有可能是Y区。这种将O区划分很多块的理念是、可以用相对较少的时间回收包含垃圾最多的缺口、

   优先回收垃圾最多区块。

调优的目的:
   内存占用
   延迟
   吞吐量



keytool list keystore cacerts 查看证书 指纹对的上就行



找出java线程占用cpu过高的线程
1、top查看占用cpu最高的进程
2、top H p xxx 找到具体线程
3、printf %x xxxx转换十六进制
4、jstatck l xxxx >jstack.log
5、查看jstack.log 找到xxxx的线程信息



tmpfs：一种基于内存的文件系统、不具备持久性。tmpfs可以使用您的内存或者swap分区来储存文件、主要储存暂存的文件。
/dev/shm  使用tmpfs文件系统、默认大小为物理内存的一半。




Reactor 单线程模型、指的是所有的IO操作都在同一个NIO线程上面完成。异步非阻塞IO、所有的IO操作都不会导致阻塞
Rector  多线程模型 一组NIO线程处理IO操作


BIO（Blocking IO）阻塞IO
NIO（NonBlocking IO）非阻塞IO
 
共同点：两者都是同步操作。即必须先进行IO操作后才能进行下一步操作。
 
不同点：BIO多线程对某资源进行IO操作时会出现阻塞，即一个线程进行IO操作完才会通知另外的IO操作线程，必须等待。
NIO多线程对某资源进行IO操作时会把资源先操作至内存缓冲区。然后询问是否IO操作就绪，是则进行IO操作，否则进行下一步操作，然后不断的轮询是否IO操作就绪，直到IO操作就绪后进行相关操作。

同步与异步，描述请求方；同步即发送请求后一直等到对方发回响应后才接着发送下一个请求，而异步机制不需要等到当前请求响应就可以继续发送下一个请求
阻塞与非阻塞，描述处理方；阻塞即调用结果返回之前，当前处理线程从运行状态被挂起，直到调用结果返回，非阻塞方式调用结果不能立即返回，当前线程也不会被挂起，而是立即返回执行下一个调用





C中main函数执行完、整个进程结束、其子线程也被强制结束退出。这是C/C++与java很大的不同。C/C++通常需要主线程等待子线程完成在退出。
而java不需要在main函数中显式等待子线程(非Daemon线程)退出、而是自动创建DestroyJavaVM线程来管理

JAVA虚拟机启动程序步骤：
1、main是启动时候的主线程、即程序入口
2、在main函数结束后、虚拟机会自动启动一个destroyJavaVM线程、该线程会等待所有user thread线程结束后退出(即、只剩下Daemon线程和DestroyJavaVM线程自己，整个虚拟机就退出、此时daemon线程被终止)。


安全点: 应用程序线程可以被安全地停止掉的时间点。需要进行VM Operation(gc/thread dump等等)时、通知所有的线程进入一个静止/一致的安全点。在安全点位置的java线程、可以被全部阻塞
打印安全点的详细详细:
                   XX:+PrintSafepointStatistics       
                   XX:PrintSafepointStatisticsCount=1 
临界区：访问的公共资源程序片段、无法同时被多个线程访问执行


栈上分配内存:
  有些对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期随着方法的调用开始而开始，方法的调用结束而结束。如果是在堆上分配，当方法调用结束，没有了引用指向该对象，该对象就需要被GC回收，而如果存在大量的这种情况，对gc来说无疑是一种负担。

  针对那些: "作用域不会逃逸出方法的对象"，在分配内存时不在将对象分配在堆内存中，而是将对象属性打散后分配在栈(线程私有的，属于栈内存)上，这样，随着方法的调用结束，栈空间的回收就会随着将栈上分配的打散后的对象回收掉，不再给GC增加额外的无用负担，从而提升应用程序整体的性能。

  优点:
    1.可以在函数调用结束后自行销毁对象，不需要垃圾回收器的介入，有效避免垃圾回收带来的负面影响。
    2.栈上分配速度快，提高系统性能。


对象为什么不在堆上分配:
   堆是线程共享、它是竞争资源、对于竞争资源、必须采取必要的同步、所以当使用new关键字在堆上分配对象时、是需要锁。
   既然有锁、就必定存在锁的开销。

  TLAB:
     TLAB 新生代中开辟了一小块区域、由线程私有。小对象优先在TLAB上分配。而且TLAB的分配是线程私有所以没有锁开销。 

    默认设定占用Eden Space的1%.



    

JVM  组成 
   ClassLoader  类加载器
   Runtime Data Area  Stack  Heap Method Area PC Register Native Method Stack 运行时数据区
    1.程序计数器
    2.java虚拟机栈
    3.本地方法栈
    4.堆
    5.栈
   Execution Engine  执行引擎
    class文件被加载后，会把指令和数据信息放入内存中，Execution Engine则负责把这些命令解释给操作系统，即将jvm指令集翻译为操作系统指令集。

   Native Interface  本地库接口
    

  流程:
    java代码翻译成class文件，通过"类加载器",把文件加载到内存中"运行时数据区"，字节码文件是一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器"执行引擎"，将字节码翻译成底层系统指令再交由cpu去执行，而这个过程需要调用其他语言的接口"本地库接口".


JVM内存模型:

  线程共享: 方法区 堆
  线程私有: 程序计数器 java虚拟机栈  本地方法栈

  程序计数器: 
           每线程私有
           记录当前线程执行程序的位置(当前执行字节码的行号)。为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各线程之间计数器互不影响，独立存储。
           字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支，循环，跳转，异常处理，线程恢复等功能都需要依赖这个计数器来完成。
           程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命随着线程的创建二创建，随着线程的结束而死亡。
  java虚拟机栈: 
              线程私有、生命周期与线程相同
              局部变量表(局部变量，各种数据类型Booblean,byte,char,short,int,float,long,double)(基本数据类型和对象引用)、操作数栈、动态链接、方法出口信息
              每个方法被执行的时候、都会创建一个栈帧用于存储局部变量表、操作栈、方法出口等信息

             StackOverFlowError: 当前线程的请求栈的深度超过当前java虚拟机栈的最大深度的时候，就抛出StackOverFlowError错误
  本地方法栈:
           线程私有
           和虚拟机栈类似、存储native方法的相关信息
          区别是: 虚拟机栈为虚拟机执行Java方法服务、而本地方法栈则为虚拟机使用到的Native方法服务
  堆:
     所有线程共享
     唯一使命存放对象实例
  方法区:
        线程共享
        存储已经被虚拟机加载的类信息、常量、静态变量、即时编译后的代码数据
        类的结构信息、如类的字段、方法、接口构造函数、还有运行时常量池等
        hotspot 虚拟机中称为永久代

  PermGen  Metaspace
     类包含其对应的元数据、比如类名、属性、方法、访问修饰符、字段信息、静态变量、常量。
  元空间与永久代之间的最大的区别在于:
    元空间并不在虚拟机中、而是使用本地内存。默认不限制内存使用，可以使用MaxMetaspaceSize指定最大值。加载的类越多metaspace占用的内存也就越大。

直接内存:
  对象分配到了堆内存以外的内存。这些内存有操作系统管理、而不是JVM、这种好处能在一定程度上减少垃圾回收对应用程序造成的影响。

  为什么使用堆外内存:
    1、减少了垃圾回收。
    2、提升复制速度(IO)效率。堆内存属于用户态、而堆外内存有os管理、属于内核态。

  注意事项:
    1、如果没有指定堆外内存限制、那么将导致内存溢出。



堆内存dump:
   jmap dump:format=b,file=xxxx pid   dump jvm堆栈
   jmap dump:live,file=xxx.bin  pid 只dump存活的对象

jmap histo:live pid 手动触发full gc
jmap histo:live  pid| less  堆中活动的对象以及大小   
jmap heap pid  查看堆的使用状况信息
jmap histo:live  pid| less 堆中活动的对象以及大小   

IBM分析工具：
java Xmx1024M jar jca457 jstack文件分析
java jar ha456.jar        Dump文件分析


JMX配置:
CATALINA_OPTS="
Djava.rmi.server.hostname=localhost
Dcom.sun.management.jmxremote.port=8686
Dcom.sun.management.jmxremote.authenticate=false
Dcom.sun.management.jmxremote.ssl=false"

JVM debug配置:
Xdebug Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=7896
   server = y 表示侦听要附加的调试器应用程序
   transport=dt_socket  是用于连接调试器的传输名称
   address = 8000 监听的地址
   suspend = n 表示不等待调试器附加


Servlet:
   是一个处理网络请求的类、用来实现web应用的。
   servlet是运行在处理网络请求的servlet容器中的、如tomcat
   servlet是一个java类

JVM 内存不足通常有两个可能的原因:
  1、JVM的内存设置太小
  2、应用程序存在内存泄露

堆溢出:
  1、堆空间设置太小。
  2、流量太大、超过处理能力

元空间溢出:
  1、第三方包的问题

栈溢出:
  1、递归无限循环

直接内存溢出:
  1、dirct out of memcahe   




逃逸分析:
  可以分析某个对象是否永远只在某个方法、线程的范围内，并没有"逃逸"出这个范围，逃逸分析的一个结果就是对于:某些未逃逸对象可以直接在栈上分配，由于该对象一定是局部的，所以栈上分配不会有问题。



对象内存分配策略:
  1.指针碰撞 
     堆内存规整(既没有内存碎片)的情况下。用过的内存全部整合到一边，没有用过的内存放到另一边，中间有一个分界值指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可

    每次new对象时，指针就会向右移动一个对象size的距离。

    假设java堆中内存是对齐的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅把指针向空闲那边挪动一段与对象大小相等的距离，这种分配方式称为指针碰撞。

  2.空闲列表   如果堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没办法进行指针碰撞了，虚拟机就必须维护一个列表，记录哪些内存是可用的。

     内存不规整的情况下。
    虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块足够大的内存块而来划分给对象实例，最后更新列表记录。

    如果堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上那些

  两种方式的选择是由java堆是否规整决定的，java堆是否规整是有选择的垃圾收集器是否具有压缩整理能力决定的。


  堆抢占:
    一个线程正在给A对象分配内存，指针还没有来的及修改，另一个为B对象分配内存的线程，又引用了这个指针来分配内存，这就发生了抢占。

    1.采用CAS分配重试的方式来保证更新操作的原子性。
    2.每个线程在java堆中预先分配一小块内存，也就是本地线程分配缓存TLAB，要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。


基本类型不放在堆里: 
  基本类型占用的空间一般都是18个字节(所需空间很少，而且因为是基本类型，所以不会出现动态增长的情况(长度是固定)，所以存放到栈上比较合适。








可见性，有序性，原子性: 


JVM中的常量池:
  1.字符串常量池:
      存放在堆中，包括string对象执行intern()方法后存的地方，双引号直接引用的字符串
  2.运行时常量池:
      存放在方法区，属于元空间，是类加载后的一些存储区域，大多数是类中constant_pool的内容
  3.类文件常量池:
      constant_pool，jvm定义的概念
     




  


NIO
  Channel负责传输
  Buffer负责存储



GC日志:
  real
    实际花费的时间，指的是从开始到结束所花费的时间。比如进程在等待I/O完成，这个阻塞时间也会被计算在内。
  user
    指的是进程在用户态，所花费的实际，只统计本进程所使用的时间，是指多核。
  sys
    指的是进程在核心态花费的CPU时间量，指的是内核中的系统调用所花费的时间，只统计本进程所使用的时间。   






过滤器与拦截器
  过滤器
    是java Sevlet规范中的一部分，只能用于web程序。
  拦截器
    可直接注入Spring容器对象，即拦截器可以注入server执行业务操作，而过滤器无法注入spring容器对象。

