封装:

	信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式(或者叫函数)来访问内部信息或者数据。

	访问权限控制。	

	意义:
		如果我们对类的属性的访问不做限制，那任何代码都可以访问，修改类中的属性。看起来更加灵活，但从另一个方面来说，过度灵活也意味着不可控，属性可以随意被各种方式修改，而且修改的逻辑散落在代码的各个角落，势必会影响代码的可读性，可维护性。

抽象:
	如何隐藏方法的具体实现。
	方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。
			










类是现实世界中事物的一个建模
	根据需求描述把其中涉及的功能，一个一个罗列出来，然后在去看哪些功能点职责相近，操作同样的属性，是否该归同一个类





类与类之间的关系:
	泛化
		可以简单理解为继承关系。
		public class A {...}
		public class B extends A {....}
	实现
		一般是指接口和实现类之间的关系
		public interfere A {.....}
		public class B implements A {......}
	关联
		是一种非常弱的关系，包含聚合，组合两种关系。如果B类对象是A类的成员变量，那B类和A类是关联关系。
		public class A {
		private B b;
		public A(B b) {
			this.b = b
		}
		}
	聚合
		是一种包含关系，A类对象包含B类对象，B类对象的生命周期可以不依赖A类对象的生命周期，也就是说可以单独销毁A类对象而不影响B对象，比如课程与学生之间的关系。

		public class A {
			private B b;
			public A(B b) {
			    this.b = b;
			}
		}

	组合
		也是一种包含关系。A类对象包含B类对象，B类对象的生命周期依赖A类对象的生命周期，B类对象不可能单独存在，比如鸟与翅膀之间的关系。
		public class A {
			private B b;
			public A() {
				this.b = new B();
			}
		}
	依赖
		是一种比关联关系更加弱的关系，包含关联关系。不管是B类对象A类对象的成员变量，还是A类的方法使用B类对象作为参数或者返回值，局部变量，只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系

		public class A {
  				private B b;
  				public A(B b) {
    				this.b = b;
  					}
		}
		或者
		public class A {
  			private B b;
  			public A() {
    		this.b = new B();
  			}
		}
		或者
		public class A {
  		public void func(B b) { ... }
		}




单例模式:
	确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。


	1.只有一个实例
	2.自行实例化(也就是主动实例化)
	3.向整个系统提供这个实例

	饿汉式单例模式:
		实现方式在类加载到内存的时候，就创建好对象了。
	懒汉式单例模式:
		在第一次使用的时候才创建对象，也就是把创建对象的时机从加载延迟到第一次使用，所以才有懒汉之分。	


建造者模式:
	将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。

	使用场景:
		创建复杂的对象。new xxx()，并且还要设置很多属性。


工厂模式:

	工厂模式是把对象的创建和适用分离开来，把创建对象的职责交给工厂类

	优点:
		解耦: 对象的创建和适用分离。
		减少代码重复，创建蔓延，降低维护成本: 对于创建较为复杂的对象，可以减少代码重复，降低维护成本。

	1)简单工厂模式
		工厂类提供创建对象的方法，接收一个参数，通过不同的参数实例化不同的产品类。

		缺点:
			当产品修改时，工厂类也要做相应的修改，违反了开-闭原则。

		适用范围:
			适用于业务简单的情况下或者产品很少增加的情况。		

	2)工厂方法模式
		为不同的产品类提供不同的工厂。
		针对每一种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品实例，相比于简单工厂来说，不再提供一个统一的工厂创建所有的对象。


		优点:
			减轻了工厂类的负担，把一种类交由一个工厂创建.
			增加产品类并不需要修改工厂类，只需要添加创建该产品的工厂即可，使得工厂类符合开放-封闭原则。
		缺点:
			对于某些可以形成一组产品的情况处理比较复杂



	3)抽象工厂模式



	简单工厂和工厂方法：
		简单工厂，是通过一个中心类来决定创建那种类型的对象，通常是通过if-else语句来实现。这种模式的优点是结构简单，使用方便。缺点是扩展性不强，当添加新的产品时，必须修改工厂类，增加相应的逻辑来创建新的产品实例，违法了开闭原则。

		工厂方法模式，通过定义一个创建对象的接口，把简单工厂的内部逻辑变成了，每个类型都有一个实现工厂类，每个工厂类实现实现工厂接口中的方法。这样做的好处是添加新产品时，只需要添加一个相应具体工厂类，无需修改现有的系统，完全符合开闭原则。




结构型模式
	说的是如何将类或者对象结合在一起形成更大的结构，就像搭积木一样，通过不同的积木组合成复杂的、功能更为强大的结构。


	适配器模式：
		定义： 在使用第三方接口，或者是为了为了兼容老的接口，创建一个适配器，该适配器会进行转换，将第三方的类转换成目标接口。
		场景：集成第三方库或旧系统，系统升级与维护。

	桥接模式：将抽象部分和实现部分分离，使它们可以独立的变化。
		场景：避免抽象与实现之间的紧密绑定。提高可扩展性：在不影响抽象的前提下独立地扩展实现，或者在不影响实现的前提下独立地扩展抽象。

	装饰器模式
		允许在不修改现有对象结构的情况下，向对象添加新的功能。它是通过创建一个包含原始对象的包装对象来实现，从而保持调用接口的一致性，同时增加新的行为和责任。

		
















为什么使用抽象类而不是接口
	原因有以下几点：
		共享代码：抽象类允许我们实现通用的功能，这些功能可以被所有子类共享。如在抽象类中实现一种默认行为或者一些辅助函数，这些都是所有具体实现类可能需要的。
		强制构造要求：可以强制子类遵循某种构造参数的模式，确保所有子类在创建时都提供必要的依赖项。就是强制子类在创建的时候必须传递参数。








聚合关系：
    表示"整体"与"部分"的关系。"部分"可以脱离"整体"而独立存在。

    比如汽车(整体)，轮胎(部分)。轮胎可以单独存在，可以被更换或用于其他车辆。


组合关系
    组合也表示"整体"与"部分"的关系，但"部分"不能脱离"整体"而存在。

    比如公司(整体)，部门(部分)。部分不能脱离公司单独存在，如果公司倒闭部门也不复存在。

关联关系
    表示对象之间的一般性连接，具有方向性。

    比如学生和老师。学生可以有多个老师，老师也可以有多个学生。它们之间存在交互，但不强调整体与部分的关系。

依赖关系
    是一种使用关系，通常在方法中使用到的参数或者局部变量。通常是在运行期间产生的。

    比如x方法依赖y。




单一职责
	焦点：
		关注的是类的设计
	目的：
		确保每个类都保持简洁专注，职责明确，从而使得类易于理解和维护。


里氏替换原则
	里氏替换原则 = 父类能被子类替换 (继承复用的规范)
	
	- 父类出现的地方都可以通过子类进行替换
	- 当子类实现父类的抽象方法时返回值不能比父类宽松。如父类中定义方法的返回值是ArrayList<String>，如果子类修改返回值为List<String>，更加宽松就会出错。允许协变(父类方法返回类型的子类型)，禁止逆变(ArrayList<String>改为List<String>)
	- 子类可以实现自己扩展的方法
	- 子类必须完全实现父类的抽象方法，而且不能覆盖父类的抽象方法。如父类的计算逻辑是add，子类覆写之后变成sub。




依赖倒置原则
	依赖抽象接口，不要依赖具体实现。
	抽象比实现稳定。

	工厂方法


迪米特法则
	类与类之间要保持最少的了解，只与直接的朋友通信。

	举例：一个电商系统中，订单处理类应该不直接与支付接口交互，而是通过一个门面或者中间来处理，以降低耦合。

接口隔离原则
	- 客户端不应该依赖它不用的接口(低耦合)。因为如何客户依赖了不需要的接口，就要面临不需要接口变动带来的风险。要求软件开发者应当那些臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。这样就保证类只知道他们需要知道的方法，不会被迫依赖于它们不使用的方法。

	- 减少不必要的实现：实现接口的类不应该被迫实现它们不需要的方法。

	焦点:
		关注的是接口的设计

	目的:
		确保接口的设计精简，不会让使用者依赖它不需要的方法。
	

	举例：假设有一个多功能打印机，支持打印、扫描和复印。应该为每一种功能提供一个单独的接口，而不是将所有功能合并到一个接口中。


















































