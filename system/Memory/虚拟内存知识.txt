虚拟内存:
	说到虚拟内存、我们先说说现在的多任务的操作系统、

	Linux内核给每个进程都提供一个独立的虚拟地址空间、并且这个地址空间是连续的。

为什么会有虚拟内存:
	1、抽象、希望操作系统给进程提供一个、进程不用关心物理内存在哪、也不需要考虑外设在哪里、只需要访问一个连续的地址空间就好了、
	2、隔离:
		因为操作系统不止运行一个进程、所以如果两个进程、那么有可能一个进程访问其他进程空间、造成数据损坏。
	3、共享内存:
		多个进程可以共享访问的地址
	4、虚拟内存:
		当多个进程运行时、会需要很大内存、所以操作系统分配给进程的是虚拟地址、只有进程真正使用到内存时、才去分配		


虚拟内存的分布:
	1. 只读段、包括代码和常量等
	2. 数据段、包括全局变量等
	3. 堆、包括动态分配的内存、从低地址开始向上增长。
	4. 文件映射段、包括动态库、共享内存等、从高地址开始向下增长。
	5. 栈、包括局部变量和函数调用的上下文等。栈的大小是固定的、一般是8MB。

页面: 内存采用的是分页机制、默认的页面是4KB、也就是小页面。如1MB的大小、则需要256个页面。

页表: 
	- 用来存放虚拟内存和物理内存对应关系的内存结构。
	- 每次访问变成两次、一次查询页表、得到物理地址、第二次通过物理地址取数据。为了加速查询页表的速度、处理器都为页表做了一个小的cache、即TLB。

MMU 全称就是内存管理单元、管理地址映射关系(也就是页表)。但MMU的性能跟CPU比还是不够快、所以又有了TLB。TLB实际上是MMU的一部分、把页表缓存起来、来提升性能。



TLB (Translation Lookaside Buffer)转译后备缓冲器。简称页表缓存、转址旁路缓存。

	- 为CPU的一种缓存、用于改进虚拟地址到物理地址转换的速度。


	简单说下、默认的内存页面大小是4KB、当我们访问数据的时候、cpu必须把虚拟内存地址转换成物理内存地址、才能访问到数据、而这个转换是需要查询页表的、cpu为了加速查找、cpu会缓存映射关系。

TLB组成:
  - TLB项由两部分组成:
  		- 标识: 存放的是虚拟地址的一部分
  		- 数据: 存放物理页号		


透明大页:
- 标准大页: 
	标准大页是预分配的、必须在引导时分配。它们难以手动管理、而且经常需要更改代码才能有效使用。
- 透明大页:
	透明大页是动态分配、是一个抽象层、可自动创建、管理和使用。



虚拟内存地址到物理内存地址是需要转换的、而这个转换是需要查表、cpu为了加速查表速度、内建了TLB缓存、而TLB大小是固定的、如果条目越多、TLB的Cache Miss也就会越高、而透明大页可以降低TLB Cache Miss、透明大页减少了TLB的条目。默认内存页大小是4KB、如果是1MB的大小、则需要256个条目、但是如果将页面大小设置为1MB呐、一条条目就可以了。


查看透明大页:
# grep Huge /proc/meminfo
AnonHugePages:         0 kB
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB

默认huge的大小为2M、当前设置是没有启用hugepage。

启用透明大页:
	echo xxx > /proc/sys/vm/nr_hugepages  xxx为透明大页数



回收内存:  当发现内存紧张时、系统会通过一些机制来回收内存

	1、回收缓存、比如使用LRU算法、回收最近最少使用的内存页面
	2、回收不经常访问的内存、把不常用的内存通过交换分区直接写到磁盘中
	3、杀死进程、内存紧张时系统还会通过OOM、直接杀掉占用大量内存的进程

	回收缓存: 系统释放掉可以回收的内存、比如buffers和cached、都属于可回收内存。它们在内存管理中、通常被叫做文件页.大部分的文件页、都是可以直接回收、以后有需要时、在从磁盘重新读取就可以了。而那些被应用程序修改过、并且还没写入磁盘的数据(脏页)、就得先写入磁盘、然后才能进行内存释放.	

    - 对文件页的回收、就是直接回收缓存、或者把脏页写回磁盘再回收。
    - 而对匿名页的回收、其实就是通过swap机制、把它们写入磁盘后在释放内存。

- 上面说内存资源紧张时、需要内存回收、如有新的大块内存分配请求、但是剩余内存不足。这个时候系统就需要回收一部分内存、进而满足新内存请求。这个过程被称为直接内存回收。

kswapd0: 内核线程、用来定时回收内存。是管理虚拟内存的进程。


SWAP:  就是将一块磁盘空间或者一个本地文件、当成内存来使用。
	- 换出: 就是将进程暂时不用的内存数据存储到磁盘中、并释放这些数据占用的内存
	- 换入: 进程在次访问这些内存的时候、把它们从磁盘读取到内存中来。

	缺点: 访问速度特别慢、严重影响性能。

	优点: 让我们的可用内存变大了、因为swap也是可用内存的一部分。还一个是说内存不足时、有些应用程序并不想被OOM杀死、而是希望能缓一段时间、等待人工介入、或者等系统自动释放其他进程的内存、再分配给它。




smem --sort swap 查看进程使用swap情况





Buffers
	是对原始磁盘块的临时存储、也就是用来缓存磁盘的数据、通常不会特别大。这样、内核就可以把分散的写记住起来、统一优化磁盘的写入、比如可以把多次小的写合并成单次大的写等等。

Cached 
	是从磁盘读取文件的页缓存、也就是用来缓存从文件读取的数据。这样、下次在访问这些文件数据时、就可以直接从内存中快速获取、而不需要再次访问缓慢的磁盘。

Buffer和Cache分别缓存的是对磁盘和文件系统的读写数据。


裸设备:
 裸分区(原始分区)、是一种没有经过格式化的分区。它有应用程序负责它进行读写。不经过文件系统缓存。

在读写普通文件时，I/O 请求会首先经过文件系统，然后由文件系统负责，来与磁盘进行交互。而在读写块设备文件时，会跳过文件系统，直接与磁盘交互，也就是所谓的"裸 I/O"。这两种读写方式使用的缓存自然不同。文件系统管理的缓存，其实就是 Cache 的一部分。而裸磁盘的缓存，用的正是 Buffer。



RSS
	表示常驻内存、把进程用到的共享内存页算了进去。所以、直接累加会导致共享内存被重复计算、不能得到准确的答案。

Pss
	私有内存 + 共享内存(按比例计算属于自己的的那一部分)	

统计所有进程占用物理内存大小:
	awk '/Pss:/ {sum += $2} END {print sum}' /proc/$$/smaps


available
	不仅包含未使用的内存、还包括了可回收的缓存。


top:
	VIRT 是进程虚拟内存的大小、只要是进程申请过的内存、即使还没真正分配物理内存也会计算在内。
	RES 是常驻内存的大小、也就是进程实际使用的物理内大小。但不包括Swap和共享内存。
	SHR 是共享内存的大小、比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。
	%MEM 是进程使用物理内存占用的百分比

memleak 可以用来检测内存泄露的工具。可以跟踪系统或指定进程的内存分配、释放请求。



kswapd0: 
	定期回收内存

	定义三个阀值: watermark也称水位
	 			pages_min 页最小阀值
	 			pages_low页最高阀值
		- 剩余内存小于页最小阈值，说明进程可用内存都耗尽了，只有内核才可以分配内存。
		- 剩余内存落在页最小阈值和页低阈值中间，说明内存压力比较大，剩余内存不多了。这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值为止。
		- 剩余内存落在页低阈值和页高阈值中间，说明内存有一定压力，但还可以满足新内存请求。
		- 剩余内存大于页高阈值，说明剩余内存比较多，没有内存压力。		


shared_memory  共享内存
	- 进程间通信的一种方式
	- 共享内存是可以有多个进程同时访问的内存、目的是在他们之间提供通信。是程序之间传递数据的有效方法。



	1、传统通信方式如: 管道、FIFO、消息队列、写入数据需要把数据从进程复制到内核、从这些IPC读取数据的时候又需要把数据从内核复制到进程。所以这种IPC方式往往需要2次在进程和内核之间进行数据的复制。
	2、它是将同一个内存区映射到共享它的不同进程的地址空间中、这样这些进程间的通信就不再需要通过内核、只需要对该共享的内存区域操作就可以了
	
shmmax 
	用于定义linux进程可以分配的单个共享内存段的最大大小


	一但剩余内存小于页低阀值、就会触发内存回收.
	/proc/sys/vm/min_free_kbytes




