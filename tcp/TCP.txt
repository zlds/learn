TCP 面向连接的、可靠的、基于字节流的传输层通信协议。建立连接后、数据可以双向传输。

	- Sequence序列号/Ack确认序列号
		- 设计的目的是为了解决应用层字节流的可靠性发送
			- 跟踪应用层的发送端数据是否送达
			- 确定接收端有序的接收到字节流

	序列号的值针对的是字节而不是报文。如一个报文号是100、字节数是50、那么确认序列号只能是151.	

TCP 握手目标
	- 同步Sequence序列号  初始序列号ISN(Initial Sequence Number) 每一个Number都代表一个字节、就是面向连接中的字节。
	- 交换TCP 通信参数	 MSS 

拥塞窗口:
	- 一个数据需要经过多个网络、而每个网络的能力有限、如果超过网络处理能力、就会发生丢包。

慢启动:
	- 由于TCP连接会穿越多个网络、所以最初并不知道网络的传输能力、为了避免发送超过网络负载的报文、TCP只能调低发送窗口、这就是慢启动
	- cwnd 拥塞窗口
		让网络变慢是通过引入拥塞窗口。
	- 如果不考虑拥塞、那么发送窗口swnd就等于对方的接收窗口rwnd

	- 如果考虑拥塞那么就是:  swnd = min(cwnd, rwnd)  发送窗口应当是拥塞窗口与对方接收窗口的最小值。这样发送速度就综合考虑了接收方和网络的处理能力了。


	- 如果是体积比较大、BDP带宽时延积很大时、那么可以调大初始拥塞窗口大小。


	查看初始拥塞窗口:
	# ss -nli|fgrep cwnd
         cubic rto:1000 mss:536 cwnd:10 segs_in:10621866 lastsnd:1716864402 lastrcv:1716864402 lastack:1716864402
    修改初始拥塞窗口:
    # ip route | while read r; do
           ip route change $r initcwnd 10;
       done     

    慢启动结束:
    	1.当网络发现丢包了。
    		- 在规定的时间内没有收到ACK报文、这说明报文丢失了、网络出现严重的拥塞、必须先降低发送速度、在进入拥塞避免阶段。如CUBIC算法会把拥塞窗口降为原先的0.8倍(发送速度降到0.8倍)。
    	2.拥塞窗口的增长到达了慢启动阈值ssthresh(slow start threshold)
    		- 虽然没有发生丢包、但发送方已经达到了曾经发生网络拥塞的速度(拥塞窗口达到了慢启动阈值)、所以会进入到不能再以指数级方式增长、而是要以线性方式增长。
    	3.接收了重复的ACK报文、可能存在丢包.
    		- 当连续收到3个重复ACK时、发送方便得到了网络发生拥塞的明确信号、就会降低发送速度。

TCP 头部字段
	- 源端口
	- 目标端口
	- 序列号  保证消息顺序
	- 确认号 保证发送方发送的数据被接收方接收
	- 偏移 也就是分片
	- 保留
	- 控制位 如FIN CLOSE
	- 窗口大小
	- 校验和
	- 紧急指针
	- TCP 可选头部

TCP Keepalive 
	1.tcp连接本身并没有长短的区分、长或短只是在描述我们使用它的方式。
	2.长/短是指多次数据变换能否复用同一个连接、而不是指连接的持续时间。
	3.TCP的keepalive仅起到保活探测的作用、和连接的长短并没有因果关系。


	长连接优势:
		1.较低的延时。用于跳过了三次握手的过程、长连接比短连接有更低的延迟。
		2.较低的带宽占用。由于不用为每个请求建立和关闭连接、长连接交换效率更高、网络带宽占用更少。

	长连接不是银弹:
		1.长连接模式下、server要和每一个client都保持连接。如果client	


UDP: 用户报文协议
	- 尽力保证数据包的送达。
	- 不需要保证送达、也不需要保证顺序、所以它没TCP协议那么复杂。
	- 用于视频 游戏、可能会丢包、但是通过减少总体延迟来降低质量。
	
	头部字段 头中只包含4个字段、每一个字段16比特。
		- 源端口是一个可选字段，它表示发送方进程的端口号，接收方可以使用该字段（不一定准确）向发送方发送信息；
		- 目的端口是数据报接收方的端口号，它只在目标的 IP 地址下才有意义；
		- 长度是协议头和数据报中数据长度的总和，表示整个数据报的大小；
		- 校验码使用IP 首部、UDP首部和数据报中的数据进行计算3，接收方可以通过校验码验证数据的准确性，发现传输过程中出现的问题；




TCP VS UDP
	1、tcp是可靠(重试、重传)  UDP追求速度(如游戏或视频流)
	2、tcp有流控
	3、tcp头部20字节  udp 头部8个字节


IP
	- 端到端的传输、提供路由和寻址功能、将数据发送到目标的主机。

	- IP数据包头部字段:
		- 32位源地址
		- 32位目的地址
		- TTL生存时间
		- 首部校验和
		- 标识
		- 标志
		- 偏移
		- 数据
		等等





端口: 可以区分同一主机的不同进程


TCP 协议号 6
UDP 协议号 17 



MTU 最大传输单元
	- 以太网和802.3对数据帧的长度都有一个限制、其最大值分别是1500和1492字节。

	- 如果发送的数据大于1500字节的数据、需要分片、接收方收到之后会进行从新组装。

	- 当不同网络上的两台主机互相进行通信时、还需要看中间网络设备的MTU、取决于路径上最小的MTU。
	- MTU 在两个方向上不一定是一致的(A到B B到A)

	- 并非是网络媒体的物理特性、相反、它是一个逻辑限制、目的的为交互使用提供足够快的响应时间。

MTU 路径发现
	- 当不同的网络主机之间通信需要跨过多个网络时、那么每个网络的链路层的MTU都可能不一样、这个时候就取决于通讯设备中最小的MTU。
	- 路径MTU发现通过在IP首部中设置"不要分片(DF)"标志、来发现当路径上的路由器是否需要IP数据报进行分片.

	- TCP路径MTU发现按照以下方式进行: 在建立连接时、TCP使用输出接口或者对端声明的MSS中最小的值、作为MTU起始的报文段大小。

PMTUD 路径最大传输单元发现 
	- 是用来确定两个主机传输路径MTU的机制

	工作原理:
	1、向目的主机发送IP头中DF控制位为1的数据包、DF是不分配的缩写
	2、路径上的网络设备根据数据包大小和自己的MTU做出不同的决定
		1、如果数据包大于设备MTU、就会丢弃数据包并发回一个包含该设备MTU的ICMP消息
		2、如果数据包小于设备的MTU、就会继续向目的主机传递数据包。
	3、源主机收到ICMP消息后、会不断使用新的MTU发送IP数据包、直到IP数据包达到目的主机。	

ARP  为IP地址到对应的硬件地址之间提供动态映射。
	- 数据链路如以太网或令牌环网都用自己的寻址机制。
	- 当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时、是根据48bit的以太网地址来确定接口的。


	数据包:
		- 硬件类型: 如1表示以太网
		- 协议类型: 如0x0800表示IPv4
		- 操作码: 如1表示请求、2表示应答


ICMP 互联网控制消息协议
	- 主要用于确定数据是否到达目的地
	- 它传递差错报文以及其他需要注意的信息。

	- 常用类型Code
		- 0 网络不可达
		- 1 主机不可达
		- 2 协议不可达
		- 3 端口不可达
		- 4 要分片但DF为1
		- 10 不允许向特定主机通信
		- 13 管理受禁


ping 检测另一台主机是否可达。 通过icmp回显请求报文给主机、并等待返回icmp回显应答。



MSL 最大报文生存时间 规定一个数据包在网络的生存时间

TTL 生存时间字段  表示数据报最多可以经过路由器的个数

RTT 往返时间








DNS 为什么使用UDP
	- 很早之前的dns查询场景中其实并不需要稳定的连接
	- 查询的数据包都非常小
	- 如果使用TCP 带来额外开销:
		- TCP 建立连接需要3次握手
		- TCP 销毁连接需要4次网络通信










组播地址:
	224.0.0.1  子网内的所有系统组
	224.0.0.2  子网内的所有路由器组
	224.0.1.1   用于NTP同步系统时钟
	224.0.0.9   用于RIP-2协议

sar -n DEV 1  查看网卡流量

	rxpck/s：每秒钟接收的数据包
	txpck/s：每秒钟发送的数据包
	rxbyt/s：每秒钟接收的字节数
	txbyt/s：每秒钟发送的字节数
	rxcmp/s：每秒钟接收的压缩数据包
	txcmp/s：每秒钟发送的压缩数据包
	rxmcst/s：每秒钟接收的多播数据包
 

sar -n EDEV 1 查看错误信息
	rxerr/s：每秒钟接收的坏数据包
	txerr/s：每秒钟发送的坏数据包
 
	coll/s：每秒冲突数
	rxdrop/s：因为缓冲充满，每秒钟丢弃的已接收数据包数
	txdrop/s：因为缓冲充满，每秒钟丢弃的已发送数据包数
	txcarr/s：发送数据包时，每秒载波错误数
	rxfram/s：每秒接收数据包的帧对齐错误数
	rxfifo/s：接收的数据包每秒FIFO过速的错误数
	txfifo/s：发送的数据包每秒FIFO过速的错误数










IANA:
0-1023 固定端口、特权端口
1024-41951 程序端口
41952+ 客户端随机使用端口;/proc/sys/net/ipv4/ip_local_prot_range;

sock_stream tcp套接字
sock_dgram  udp套接字
sock_raw    raw套接字


AF_INET：IPV4
AF_INET6：IPV6
AF_UNIX：同一主机上的不同进程间基于socket套接字通信使用的一种地址；
Unix_SOCK同一台主机的进程间通信、不需要经过网络协议栈、不需要打包拆包、计算校验和、维护序号和应答等、而是将应用层数据从一个进程拷贝到另外一个进程。

tcp fsm： LISTEN,SYN_SENT,SYN_RECV,ESTABLISHED,FIN_WAIT1,CLOSE_WAIT,FIN_WAIT2,LSAT_ACK,TIMEWAIT,CLOSED



快速重传
比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6
Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。


SACK 方法
另外一种更好的方式叫：Selective Acknowledgment (SACK)（参看RFC 2018），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版
这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过tcp_sack参数打开这个功能（Linux 2.4后默认打开）。

这里还需要注意一个问题——接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。

注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《TCP SACK的性能权衡》